// Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../references.ts" />
/// <reference path="../compilers/Compiler.ts" />
/// <reference path="../modules/Module.ts" />
/// <reference path="../modules/ModuleExport.ts" />
/// <reference path="Route.ts" />

module appex {
    
    export class Runtime {    

        public routes   : appex.Route[];

        constructor(public module:appex.Module)  {   
             
            this.setup();
        }

        public setup() : void  {

            this.routes = [];
            
            this.module.exports.forEach((handle) => {

                var route = new appex.Route(handle);
                 
                if(route.type != 'invalid') {
                
                    this.routes.push(route);
                }
            });
        }
        
        public read_request_object(request:http.ServerRequest, callback:(obj:any) => void) : void {
           
            var buffer = [];

            request.on('data', (chunk) => { 
                
                buffer.push(chunk); 
            
            });

            request.on('end', () => { 
                
                try  {

                    var obj = JSON.parse( buffer.join('') );

                    callback(obj);
                } 
                catch(error) {

                    callback(null);
                }
            }); 
        }

        public write_response_object(output:any, response:http.ServerResponse, callback:()=>void) : void {
            
            try {

                var json = JSON.stringify(output, null, '');
                
                response.writeHead(200, {'content-type' : 'application/json'});

                response.write(json);

                response.end();

            } 
            catch(error) {

                response.writeHead(200, {'content-type' : 'application/json'});

                response.write(error.toString());

                response.end();
            }
            
            callback();
        }

        public handler (request:http.ServerRequest, response:http.ServerResponse, next? : () => void) : boolean {

            var url = node.url.parse(request.url);

            for(var n in this.routes) {

                var route = <appex.Route>this.routes[n];
                
                if(url.pathname == route.url) {

                    var method = this.module.get(route.moduleExport);
                    
                    // snap in appex helpers

                    var appex_request = <any>request;


                    var appex_response = <any>response;

                    appex_response.writeFile = (mime:string, filename:string) => {
                    
                        response.writeHead(200, {'content-type': mime});

                        node.fs.readFile(filename, (error, data) =>{
                            
                            if(error) {
                            
                                response.write(error.message);

                                response.end();

                                return;
                            }

                            response.write(data);

                            response.end();
                        });
                    };
                    

                    // create the context

                    var context = {

                        request     : appex_request, 

                        response    : appex_response,

                        routes      : this.routes,

                        reflection  : this.module.reflection,

                        exports     : this.module.exports
                    };

                    switch(route.type) {
                        
                        case 'handler':

                            method( context );

                            break;

                        case 'method':

                            this.read_request_object(request, (input) => {

                                method( context, input, (output) => {
                                
                                    this.write_response_object(output, response, ()=> {
                                
                                        // do something here?
                                    });
                                });
                            });

                            break;
                    }

                    return true; // was handled
                }
            }
            
            if(next) {

                next();
            }

            return false; // was not handled
        }
    }
}