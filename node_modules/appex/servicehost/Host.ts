// Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../decl/node.d.ts" />
/// <reference path="../activation/ActivationContext.ts" />
/// <reference path="Route.ts" />
/// <reference path="Meta.ts" />

module appex.servicehost {

    export class Host
    {
        public activation : appex.activation.ActivationContext;

        public meta       : appex.servicehost.Meta;
        
        public routes     : Array<appex.servicehost.Route>;

        public discovery  : boolean;

        constructor(activation:appex.activation.ActivationContext)
        {
            this.activation = activation;
            
            this.setup_meta();

            this.setup_routes();
        }
        
        private setup_meta          () : void {
        
            this.meta = new appex.servicehost.Meta(this.activation);
        }

        private setup_routes        (): void {

            this.routes = new Array<appex.servicehost.Route>();
            
            this.activation.handles.forEach((handle) => {
                
                var instance = handle.activate();

                var basepath = '/' + handle.typename.replace(/\./g, '/');

                basepath = basepath.replace(/\/\//g, '/');

                handle.typeinfo.methods.forEach((method) => {
                    
                    if(!method.isConstructor) {
                        
                        var route      = new appex.servicehost.Route();

                        route.path     = [basepath, method.name].join('/').toLowerCase();

                        route.instance = instance;
                        
                        route.method   = method.name;

                        // if there is one parameter, its synchronous.

                        if(method.parameters.length == 1) {
                            
                            route.async = false;

                            route.input = method.parameters[0].type;

                            route.output = method.returns;
                        }

                        // if there are two parameters, its asynchronous.

                        if(method.parameters.length == 2) {
                            
                            if(method.parameters[1].type.name == "Function") {

                                route.async = true;

                                route.input = method.parameters[0].type;

                                route.output = method.parameters[1].type;
                            }   
                        }
                        
                        this.routes.push(route);     
                    }
                });
            });        
        }

        private read_body           (request:http.ServerRequest, callback: (buffer:string)=>void) : void {
        
            var buffer = [];

            request.on('data', (chunk) => { buffer.push(chunk); });

            request.on('end',  ()      => { callback(buffer.join('')); });
        }

        private error_handler       (error:string, request:http.ServerRequest, response:http.ServerResponse) : void {
            
            response.writeHead(500, { 'content-type' : 'text/plain'});

            response.write(error.toString());

            response.end();      
        }
        
        private discovery_handler   (request:http.ServerRequest, response:http.ServerResponse) : void {
        
            response.writeHead(200, { 'content-type' : 'text/plain'});

            response.write('output meta info here.');

            response.end();  
        }
                
        private route_handler       (context:any, request:http.ServerRequest, response:http.ServerResponse, callback:(handled:boolean)=>void) : void {
            
            if(this.routes.length == 0) {
            
                callback(false);

                return;
            }

            var handled = false;

            for(var n in this.routes)
            {   
                var route = this.routes[n];

                if(route.path == request.url) 
                {
                    handled = true;
                    
                    // apply the context

                    route.instance.context = context;
                    
                    // unpack the request.

                    var buffer = [];

                    this.read_body(request, (buffer) => { 
                        
                        var input = null;

                        try 
                        {
                            input = JSON.parse(buffer);
                        }
                        catch(e) 
                        {
                                    
                        }
                        
                        try 
                        {
                            if(route.async)  // asynchronous calling convention
                            {
                                route.call(input, (output) => {
                                    
                                    var json = 'null'; 
                                    
                                    if(output)
                                    {
                                        json = JSON.stringify(output, null, ' ');
                                    }
                                    
                                    response.writeHead(200, { 'content-type' : 'application/json'});

                                    response.write(json);

                                    response.end();

                                    callback(handled);
                                });
                            }  
                            else  // synchronous calling convention
                            {  
                                var output = route.call(input);

                                var json   = 'null'; 
                                    
                                if(output)
                                {
                                    json = JSON.stringify(output, null, ' ');
                                }

                                response.writeHead(200, { 'content-type' : 'application/json'});

                                response.write(json);

                                response.end();

                                callback(handled);

                                return;
                            }
                        } 
                        catch(error) 
                        {
                            this.error_handler(error.toString(), request, response); 
                            
                            callback(handled);

                            return;                         
                        }
                    });

                    break;
                } 
            }
            callback(handled);
        }
        
        public  bind                (server:http.Server) : void {
        
            var listeners = server.listeners('request');
         
            server.removeAllListeners('request');
            
            server.on('request', (request:http.ServerRequest, response:http.ServerResponse) => {
                
                // handle appex discovery requests.

                if(request.url == '/appex') {
                
                    if(this.discovery) {
                    
                        this.discovery_handler(request, response);

                        return;
                    }
                }

                var context = {
                    
                    server : server,

                    request : request,

                    response : response
                
                };

                this.route_handler(context, request, response, (handled) => {
                    
                    if(!handled) {

                        for(var n in listeners) 
                        {
                            listeners[n](request, response);
                        }
                    }       
                });
            });            
        }

        public call                 (path:string, input:any) : any {
        
            for(var n in this.routes) {

                if(this.routes[n].path == path) {
                
                    var output = this.routes[n].call(input);

                    return output;
                }
            }

            return null;
        }
    }
}