// Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../decl/node.d.ts" />
/// <reference path="../activation/ActivationContext.ts" />
/// <reference path="Route.ts" />
/// <reference path="Service.ts" />

module appex.servicehost
{
    export class Host
    {
        public activation : appex.activation.ActivationContext;

        public services   : Array<appex.servicehost.Service>;

        public routes     : Array<appex.servicehost.Route>;

        constructor(activation:appex.activation.ActivationContext)
        {
            this.activation = activation;
            
            this.setup();
        }

        public call(path:string, input:any) : any {
        
            for(var n in this.routes) {

                if(this.routes[n].path == path) {
                
                    var output = this.routes[n].call(input);

                    return output;
                }
            }

            return null;

        }
        
        private setup(): void 
        {
            this.routes     = new Array<appex.servicehost.Route>();

            this.activation.handles.forEach((handle) => {
                
                var instance = handle.activate();

                var basepath = '/' + handle.typename.replace(/\./g, '/');

                handle.typeinfo.methods.forEach((method) => {
                    
                    if(method.name != 'constructor') {

                        var route      = new appex.servicehost.Route();

                        route.path     = [basepath, method.name].join('/').toLowerCase();

                        route.instance = instance;
                        
                        route.method   = method.name;

                        // if there is one parameter, its asynchronous.

                        if(method.parameters.length == 1) {
                            
                            route.async = false;

                            route.input = method.parameters[0].type;

                            route.output = method.returns;
                        }

                        // if there are two parameters, its async.

                        if(method.parameters.length == 2) {
                            
                            if(method.parameters[1].type.name == "Function") {

                                route.async = true;

                                route.input = method.parameters[0].type;

                                route.output = method.parameters[1].type;
                            }   
                        }
                        
                        this.routes.push(route);     
                    }
                });
            });        
        }
    }
}