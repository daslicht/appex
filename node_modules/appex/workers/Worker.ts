// appex - Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../references.ts" />
/// <reference path="../interfaces.ts" />

module appex {

    // passed between parent and child context.
    class Message<T>  {

        type      : string;

        messageid : number;

        body      : T;
    }
    
    class Waiter<Response> {

        constructor(public messageid : number,

                    public delegate  : (response:Response) => void) { }
    }

    export class Worker<TRequest, TResponse> implements appex.IDisposable {
    
        private child_process  : child_process.ChildProcess;

        private waiters        : Array< Waiter <TResponse> >;

        private message_index  : number;

        constructor(public delegate : (request:TRequest, callback:(response:TResponse) => void) => void) {
        
            this.message_index = 0;

            this.waiters     = new Array< Waiter<TResponse> >();
            
            // create setup message.

            var message       = new Message();

            message.messageid = 0;

            message.type      = 'setup';

            message.body      = {
                
                code        : this.delegate.toString(),
                
                filename    : process.mainModule.filename,
            };

            // initialize the worker

            this.child_process = node.child_process.fork(__dirname + '/kernel.js');

            this.child_process.on('message', (message:Message<TResponse>) => { 
                
                this.dispatch(message); 
            
            });

            this.child_process.send(message, null);
        }

        private dispatch(message:Message<TResponse>) : void {
            
            // foreach callback, compare for messageid and dispatch.

            for(var i = 0; i < this.waiters.length; i++) {
        
                if(this.waiters[i].messageid == message.messageid) {
            
                    this.waiters[i].delegate( message.body );

                    this.waiters.splice(i, 1);

                    break;
                }
            }
        }

        public call(request:TRequest, callback:(response:TResponse) => void): void {
        
            // push call back on queue.

            this.waiters.push(new Waiter<TResponse>(this.message_index, callback));

            // setup the message.

            var message       = new Message<TRequest>();
        
            message.messageid = this.message_index;

            message.type      = 'call';

            message.body      = request;

            // send..

            this.child_process.send(message, null);

            // increment the message index

            this.message_index = this.message_index + 1;
        }

        public dispose(): void {
        
            // destroy the worker process.
            try 
            {
                this.child_process.kill();
            } 
            catch (error) 
            {
                
            }
        }
    }
}