// Copyright (c) 2013 haydn paterson (sinclair).  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../references.ts" />
/// <reference path="../interfaces.ts" />
/// <reference path="Message.ts" />
/// <reference path="Waiter.ts" />

module appex.workers {
    
    /** appex worker. a class used differ heavy lifting out to a child_process */
    export class Worker<TRequest, TResponse> implements appex.IDisposable {
        
        /* the nodejs child_process managed by the worker */
        private child_process  : child_process.ChildProcess;


        /* any waiters that have issued requests to this worker */
        private waiters        : Array< Waiter <TResponse> >;


        /* a message index that gets incremented on each call (see messageid) */
        private message_index  : number;


        /* arguments:
        *       delegate: the function to be executed in the child_process.
        */
        constructor(public delegate : (request:TRequest, callback:(response:TResponse) => void) => void) {
        
            this.message_index = 0;

            this.waiters     = new Array< Waiter<TResponse> >();
            
            // create setup message.

            var message       = new Message();

            message.messageid = 0;

            message.type      = 'setup';

            message.body      = {
                
                code        : this.delegate.toString(),
                
                filename    : process.mainModule.filename,
            };

            // initialize the worker
            this.child_process = node.child_process.fork(__dirname + '/kernel.js');

            var that = this;

            this.child_process.on('message', function(message:Message<TResponse>) { 
                
                that.dispatch(message);
            
            });

            this.child_process.send(message, null);
        }


        /** dispatches responses to callers.
        *
        *   arguments:
        *       message - the message to dispatch.
        */
        private dispatch(message:Message<TResponse>) : void {
            
            // foreach callback, compare for messageid and dispatch.

            for(var i = 0; i < this.waiters.length; i++) {
        
                if(this.waiters[i].messageid == message.messageid) {
            
                    this.waiters[i].delegate( message.body );

                    this.waiters.splice(i, 1);

                    break;
                }
            }
        }

        /** calls the worker.
        *
        *   arguments:
        *       request  - the request to send to the worker.
        *       callback - the callback function containing a response from the worker.
        */
        public call(request:TRequest, callback:(response:TResponse) => void): void {
        
            // push call back on queue.

            this.waiters.push(new Waiter<TResponse>(this.message_index, callback));

            // setup the message.

            var message       = new Message<TRequest>();
        
            message.messageid = this.message_index;

            message.type      = 'call';

            message.body      = request;

            // send..

            this.child_process.send(message, null);

            // increment the message index

            this.message_index = this.message_index + 1;
        }

        /** disposes this worker by terminating its child_process */
        public dispose(): void {

            try {

                this.child_process.kill();
            } 
            catch (error) {
                
            }
        }
    }
}