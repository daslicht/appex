// Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../references.ts" />
/// <reference path="../modules/Module.ts" />
/// <reference path="../modules/ModuleExport.ts" />
/// <reference path="Route.ts" />
/// <reference path="Mime.ts" />

module appex {
    
    export class Router {
            
        public routes : appex.Route[];

        public mime   : appex.Mime;

        constructor(public module:appex.Module)  {   
             
            this.routes = [];
            
            this.mime   = new appex.Mime();

            this.module.exports.forEach((handle) => {

                var route = new appex.Route(handle);
                 
                if(route.type != 'invalid') {
                
                    this.routes.push(route);
                }
            });
        }
        
        private read_request_object   (request:http.ServerRequest, callback:(obj:any) => void) : void {
           
            var buffer = [];

            request.on('data', (chunk) => { 
                
                buffer.push(chunk); 
            
            });

            request.on('end', () => { 
                
                try  {

                    var obj = JSON.parse( buffer.join('') );

                    callback(obj);
                } 
                catch(error) {

                    callback(null);
                }
            }); 
        }

        private write_response_object (output:any, response:http.ServerResponse, callback:()=>void) : void {
            
            try {

                var json = JSON.stringify(output, null, '');
                
                response.writeHead(200, {'content-type' : 'application/json'});

                response.write(json);

                response.end();

            } 
            catch(error) {

                response.writeHead(200, {'content-type' : 'application/json'});

                response.write(error.toString());

                response.end();
            }
            
            callback();
        }

        public request_handler        (serverRequest:http.ServerRequest, serverResponse:http.ServerResponse, next? : () => void) : boolean {

            var url = node.url.parse(serverRequest.url);
            
            for(var n in this.routes) {

                var route = <appex.Route>this.routes[n];
                
                if(route.match(url.pathname)) {

                    var method = this.module.get(route.moduleExport);
                    
                    // snap in appex helpers

                    var appex_request  = <any>serverRequest;
                    
                    var appex_response = <any>serverResponse;

                    appex_response.writeFile = (mime:string, filename:string) => {
                    
                        serverResponse.writeHead(200, {'content-type': mime});

                        node.fs.readFile(filename, (error, data) =>{
                            
                            if(error) {
                            
                                serverResponse.write(error.message);

                                serverResponse.end();

                                return;
                            }

                            serverResponse.write(data);

                            serverResponse.end();
                        });
                    };
                    

                    // create the context

                    var context = {

                        request     : appex_request, 

                        response    : appex_response,

                        routes      : this.routes,

                        reflection  : this.module.reflection,

                        exports     : this.module.exports,

                        mime        : this.mime,
                    };

                    switch(route.type) {
                        
                        case 'handler':

                            method( context );

                            break;

                        case 'method':

                            this.read_request_object(serverRequest, (input) => {

                                method( context, input, (output) => {
                                
                                    this.write_response_object(output, serverResponse, ()=> {
                                
                                        // do something here?
                                    });
                                });
                            });

                            break;

                        case 'wildcard':

                            var arguments:any[] = route.parameters(url.pathname);

                            arguments.unshift(context)

                            method.apply(this, arguments);
                            
                            break;
                    }

                    // return to the caller if this request was handled or not.
                    return true; 
                     
                }
            }
            
            // if the route was not handled, and, because we want some integration with 
            // connect/express middleware, we call next to defer the request out to
            // connect handlers.
            if(next) {  next();  }
            
            // return to the caller if this request was handled or not.
            return false;  
        }
    }
}