// Copyright (c) sinclair 2013.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../references.ts" />
/// <reference path="../modules/ModuleExport.ts" />

module appex 
{    
    export class Route {
           
        public moduleExport : appex.ModuleExport;

        public type         : string; 

        public path         : string;

        public regexp       : RegExp;
        
        public inputType    : typescript.api.Type; 

        public outputType   : typescript.api.Type;
        
        constructor(moduleExport : appex.ModuleExport)
        {    
            this.moduleExport = moduleExport;

            this.path        = '';

            this.type        = 'unknown';

            this.regexp      = null;

            this.inputType   = null;

            this.outputType  = null;

            this.setup();
        }

        // match the incoming url.
        public match(path:string) : boolean {
        
            if(this.type == 'wildcard') {
                
                console.log('before');

                var result =  this.regexp.test(path);

                console.log('after');

                console.log(result)

                return result;
                
            } else {
            
                return path == this.path;
            }
        }
        // load arguments from the incoming url
        public parameters(path:string) : string[] {

            var result = [];

            var match = this.regexp.exec(path);
            
            if(match) 
            {
                var index = 0;

                for(var n in match) 
                {
                    if(n != '0' && n != 'index' && n != 'input') 
                    {
                        result.push(match[n]);

                        index += 1;
                    }
                }
            }
            return result;
        }


        private setup() : void {
        
            if(this.moduleExport.type.identifier == "method") 
            {
                this.setup_url  (<typescript.api.Method>this.moduleExport.type);

                this.setup_type (<typescript.api.Method>this.moduleExport.type);

                if(this.type == 'wildcard') {
                
                    this.setup_wildcard(<typescript.api.Method>this.moduleExport.type)   
                
                }
            }
            else 
            {
                this.type = 'invalid';
            }
        }

        private setup_url (method:typescript.api.Method) : void  {
                
            var name = method.name.toLowerCase();

            if(this.moduleExport.scope.length == 0) {
                    
                this.path = name == 'index' ? "/" : '/' + name;
            } 
            else  {
                    
                this.path = name == 'index' ? ('/' + this.moduleExport.scope.join('/')) : ('/' + this.moduleExport.scope.join('/') + '/' + name);
            }
        }

        private setup_type(method:typescript.api.Method) : void {
            
            if(method.name == 'wildcard') {
                
                if(method.parameters.length > 1) {

                    this.type = 'wildcard';

                    return;
                }
            }


            if(method.parameters.length == 1) {
            
                this.type = 'handler';

                return;

            }

            if(method.parameters.length == 3) {
            
                if(method.parameters[2].type.name == "Function") {
     
                    if(method.parameters[2].type.signature.parameters.length == 1) {
                        
                        if(method.parameters[2].type.signature.parameters[0].type.name != "Function") {
                            
                            this.type      = 'method';

                            this.inputType = method.parameters[1].type;
            
                            this.outputType = method.parameters[2].type.signature.parameters[0].type;

                            return;
                        }
                    }
                }   
            }

            this.type = 'invalid';
        }
        
        private setup_wildcard(method:typescript.api.Method) : void {
            
            var buffer = [];

            buffer.push("^");

            buffer.push('/', this.moduleExport.scope.join('/'));
            
            for(var i = 1; i < method.parameters.length; i++) {
                  
                buffer.push('/(.*)');
            }

            buffer.push('$');
            
            this.regexp = new RegExp(buffer.join(''));
        }
    }
}