/// <referecne path="../references.ts" />
/// <reference path="../interfaces.ts" />
/// <reference path="../compiler/Compiler.ts" />
/// <reference path="../modules/Module.ts" />
/// <reference path="RuntimeOptions.ts" />
/// <reference path="RuntimeRequest.ts" />
/// <reference path="Router.ts" />

module appex {
    
    export class Runtime implements appex.IDisposable {
        
        private compiler       : appex.Compiler;

        private module         : appex.Module;

        private router         : appex.Router;

        private runtime_request_queue  : appex.RuntimeRequest[];

        private options        : RuntimeOptions;

        private compiled       : boolean;

        private compiling      : boolean;

        constructor(options : appex.IRuntimeOptions) {
            
            this.compiler        = new appex.Compiler();

            this.options         = new appex.RuntimeOptions(options);

            this.module          = null;

            this.router          = null;

            this.runtime_request_queue = [];

            this.compiled              = false;

            this.compiling             = false;

            this.options.stdout.write('appex ');

            this.options.devmode ? this.options.stdout.write('\033[32m- development mode\033[0m\n') : this.options.stdout.write('\n');
        }
        
        // runtime entry point. 
        public request_handler (serverRequest : http.ServerRequest, serverResponse : http.ServerResponse, next : () => void) : void {
            
            // because we are compiling behind the scenes, and 
            // because we may receive multiple requests during 
            // this time, we cache them to process them later on..
            this.runtime_request_queue.push ( new appex.RuntimeRequest(serverRequest, serverResponse, next ) );
            
            this.prepare_module_and_router( (diagnostics) => {
                
                // if we have diagnostic errors, we need to write 
                // this out to all pending requests. If one module 
                // is bad, then they are all bad.
                if(diagnostics)  {    

                    while(this.runtime_request_queue.length > 0) {

                        var request = this.runtime_request_queue.pop ();

                        request.serverResponse.writeHead(500, {'content-type' : 'text/plain'});

                        diagnostics.forEach((diagnostic) => {
    
                            var message = [];
                            
                            message.push( diagnostic.path )
                            
                            message.push(" [" , (diagnostic.line_index + 1).toString(),  ":" , (diagnostic.char_index + 1).toString() , "] ");
                            
                            message.push(diagnostic.message, '\n');

                            request.serverResponse.write(message.join(''));

                            if(this.options.logging) {

                                this.options.stderr.write( message.join('') );
                            }
                        });

                        request.serverResponse.end();
                    }                   

                    return;
                }
                

                // if we have successfully obtained a working 
                // module, then we need to try handle the request, 
                // all pending requests are pushed out the the 
                // router to be handled. routes that do not match are
                // ignored by the router.
                while(this.runtime_request_queue.length > 0) {

                    var request = this.runtime_request_queue.pop ();

                    var handled = this.router.request_handler (request.serverRequest, request.serverResponse, request.next);

                    // if the request was handled by the router,
                    // then output some meaningful stuff. 
                    if(handled) {
                        
                        if(this.options.logging) {

                            var message = [];

                            message.push(request.serverRequest.method , ' ');

                            message.push('[' , request.stopwatch.stop().toString() , 'ms] ');

                            message.push(request.serverRequest.url, '\n');

                            this.options.stdout.write(message.join(''));
                        }
                    }
                }
            });
        }

        // prerare module and router by compiling 
        // sourcefile and applying the result to 
        // this classes instances. if already compiled,
        // will simply callback.
        private prepare_module_and_router (callback: (diagnostics:typescript.api.Diagnostic[]) => void ) : void {
            
            if(this.options.devmode) {
                
                this.compiled = false;
            }

            if(this.compiled) {
            
                callback(null);
            }

            if(!this.compiled) {

                this.compiling = true;
                
                this.compiler.compile(this.options.sourcefile, (result) => {
                    
                    this.compiling = false;

                    if(result.diagnostics.length > 0) {
                    
                        callback(result.diagnostics);

                        return;
                    }
                    
                    this.module     = new appex.Module(result.javascript, result.reflection);

                    this.router     = new appex.Router(this.module);

                     this.compiled  = true;

                    callback(null);

                    // as the compiler is running in a background 
                    // child_process, need should dispose of it
                    // if we are not using it anymore. If not running
                    // devmode, dispose of it.
                    if(!this.options.devmode) {
                    
                        this.compiler.dispose();
                    }

                });
            }        
        }
        
        
        public dispose() : void {
        
            this.compiler.dispose();

            this.module.dispose();
        }
    }
}